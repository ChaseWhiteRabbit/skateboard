<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rift Skateboard - Exact Replica</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            background: white;
            overflow: hidden;
            height: 100vh;
        }

        html, body {
            margin: 0;
            height: 100%;
            overflow: hidden; 
        }

        .main_content_scroll {
            overflow-y: scroll;
            height: 100%;
            pointer-events: all;
        }

        .main_content_scroll::-webkit-scrollbar {
            width: 0px;
            display: none;
        }

        #bear-holder {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 98;
            pointer-events: none;
        }

        .content {
            height: 500vh; /* Make it scrollable */
            position: relative;
            z-index: 1;
        }

        .section {
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: #010031;
            font-family: Arial, sans-serif;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(2px);
        }

        .section:nth-child(even) {
            background: rgba(240, 240, 240, 0.1);
        }

        .skateboard-section {
            background: rgba(255, 255, 255, 0.2);
            flex-direction: column;
            gap: 20px;
        }

        .skateboard-section h1 {
            font-size: 3rem;
            margin: 0;
            background: linear-gradient(90deg, #FF66CC 6.25%, #445FFF 94.27%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        .skateboard-section p {
            font-size: 1.5rem;
            margin: 0;
            text-align: center;
            max-width: 800px;
        }

        .loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #010031;
            font-family: Arial, sans-serif;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .noise {
            -webkit-animation: noise 1.2s steps(3) infinite both;
            animation: noise 1.2s steps(3) infinite both;
            background: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiBmaWxsPSJibGFjayIgZmlsbC1vcGFjaXR5PSIwLjEiLz4KPHN2Zz4K");
            background-size: 64px;
            height: 200%;
            left: -50%;
            pointer-events: none;
            position: fixed;
            top: -50%;
            width: 200%;
            will-change: auto;
            z-index: 100;
            opacity: 0.05;
        }

        @keyframes noise {
            0% { -webkit-transform: translate3d(1%,-1%,0); transform: translate3d(1%,-1%,0) }
            10% { -webkit-transform: translate3d(-5%,-2%,0); transform: translate3d(-5%,-2%,0) }
            20% { -webkit-transform: translate3d(10%,5%,0); transform: translate3d(10%,5%,0) }
            30% { -webkit-transform: translate3d(5%,-11%,0); transform: translate3d(5%,-11%,0) }
            40% { -webkit-transform: translate3d(-12%,-5%,0); transform: translate3d(-12%,-5%,0) }
            50% { -webkit-transform: translate3d(10%,9%,0); transform: translate3d(10%,9%,0) }
            60% { -webkit-transform: translate3d(15%,0,0); transform: translate3d(15%,0,0) }
            70% { -webkit-transform: translate3d(-10%,8%,0); transform: translate3d(-10%,8%,0) }
            80% { -webkit-transform: translate3d(10%,2%,0); transform: translate3d(10%,2%,0) }
            90% { -webkit-transform: translate3d(1%,5%,0); transform: translate3d(1%,5%,0) }
            to { -webkit-transform: translate3d(0,8%,0); transform: translate3d(0,8%,0) }
        }
    </style>
</head>
<body>
    <div class="noise"></div>
    
    <div class="loader" id="loader">
        <div>Loading Rift Skateboard...</div>
        <div id="progress">0%</div>
    </div>

    <div id="bear-holder"></div>

    <section class="main_content_scroll" id="new_body">
        <div class="content">
            <div class="section">
                <h1>Scroll down to see the skateboard in action</h1>
            </div>
            
            <div class="section skateboard-section">
                <h1>Rift Skateboard</h1>
                <p>This 3D skateboard rotates and moves with your scroll, exactly like in the original Rift app</p>
            </div>
            
            <div class="section">
                <h1>Keep scrolling...</h1>
            </div>
            
            <div class="section">
                <h1>The camera follows your scroll movement</h1>
            </div>
            
            <div class="section">
                <h1>End of demo - scroll back up!</h1>
            </div>
        </div>
    </section>

    <script src="three.min.js"></script>
    <script src="OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/geometries/TextGeometry.js"></script>
    
    <script>
        let scene, camera, renderer, sphereCamera, skate, letterT;
        let new_body = document.getElementById("new_body");
        let loader = document.getElementById("loader");
        let progress = document.getElementById("progress");
        let tOriginalY = 0; // Store T's original Y position
        let bounceTime = 0; // Time counter for bounce animation
        let animationPhase = 'hitBackground'; // Current animation phase: 'hitBackground', 'pause', 'bounce', 'settled'
        let phaseTimer = 0; // Timer for current phase
        let hitBackgroundDuration = 60; // Frames to move to background
        let pauseDuration = 30; // Frames to pause at background
        let maxBounceTime = Math.PI * 4; // Allow for about 2 full bounces before stopping

        function init() {
            const loadingManager = new THREE.LoadingManager(
                //loaded
                () => {
                    console.log("loaded 3d");
                    clearLoader();
                    const t = new_body.scrollTop;
                    camera.position.y = t * -0.004;
                    render();
                },
                //progress
                (itemUrl, itemsLoaded, itemsTotal) => {
                    const percent = Math.round((itemsLoaded / itemsTotal) * 100);
                    progress.textContent = `${percent}%`;
                    console.log(percent + "% loaded");
                }
            );

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 50);
            camera.position.set(0, 0, 5);

            renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
            renderer.setClearColor( 0xffffff, 0 );
            renderer.autoClear = false;
            renderer.setSize(window.innerWidth, window.innerHeight);

            document.getElementById('bear-holder').appendChild(renderer.domElement);

            // Create cube camera for environment reflections (exact original implementation)
            sphereCamera = new THREE.CubeCamera(1, 9000000000000, 500);
            sphereCamera.position.set(0, 0, 0);
            scene.add(sphereCamera);
            
            // Exact original material from Rift app
            let skateMaterial = new THREE.MeshPhongMaterial({
                envMap: sphereCamera.renderTarget.texture
            });

            const loaderS = new THREE.OBJLoader(loadingManager);

            loaderS.load(
                'skateboard.obj',
                function(object3) {
                    console.log('Skateboard loaded successfully:', object3);
                    object3.traverse(function(child) {
                        if (child instanceof THREE.Mesh) {
                            console.log('Found mesh:', child);
                            child.material = skateMaterial;
                            child.material.flatShading = false;
                            skate = object3;
                        }
                    });

                    scene.add(object3);
                    console.log('Skateboard added to scene');

                    // Responsive positioning exactly like original
                    if (window.innerWidth < 420) {
                        object3.position.y = -3.38;
                        object3.position.x = 1.6;
                        object3.scale.set(1.3, 1.3, 1.3);
                    }
                    else if (window.innerWidth < 770) {
                        object3.position.y = -2.3;
                        object3.position.x = 1;
                        object3.scale.set(1.2, 1.2, 1.2);
                    }
                    else if (window.innerWidth < 1050) {
                        object3.position.y = -1.3;
                        object3.position.x = 1;
                        object3.scale.set(1, 1, 1);
                    }
                    else if (window.innerWidth < 1500) {
                        object3.position.y = -3.8;
                        object3.position.x = 0;
                        object3.scale.set(1.3, 1.3, 1.3);
                    }
                    else if (window.innerWidth < 1550) {
                        object3.position.y = -3.7;
                        object3.position.x = 0;
                        object3.scale.set(1.3, 1.3, 1.3);
                    }
                    else {
                        object3.position.y = -3.5;
                        object3.position.x = 0;
                        object3.scale.set(1.3, 1.3, 1.3);
                    }
                    
                    // Create the letter T after skateboard is loaded to sync rotation
                    createLetterT();
                },
                function(xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                function(error) {
                    console.log('An error happened');
                }
            );

            // Create 3D letter T with same material as skateboard
            function createLetterT() {
                // Create T shape with rounded edges using rounded rectangles
                function createRoundedRectShape(width, height, radius) {
                    const shape = new THREE.Shape();
                    const x = -width / 2;
                    const y = -height / 2;
                    
                    shape.moveTo(x, y + radius);
                    shape.lineTo(x, y + height - radius);
                    shape.quadraticCurveTo(x, y + height, x + radius, y + height);
                    shape.lineTo(x + width - radius, y + height);
                    shape.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
                    shape.lineTo(x + width, y + radius);
                    shape.quadraticCurveTo(x + width, y, x + width - radius, y);
                    shape.lineTo(x + radius, y);
                    shape.quadraticCurveTo(x, y, x, y + radius);
                    
                    return shape;
                }
                
                // Create the T shape by combining two rounded rectangles
                const tShape = new THREE.Shape();
                
                // Horizontal bar (top) - rounded rectangle
                const horizontalBar = createRoundedRectShape(3, 0.5, 0.2); // width=3, height=0.5, radius=0.2
                // Vertical bar (center) - rounded rectangle  
                const verticalBar = createRoundedRectShape(0.6, 2.5, 0.2); // width=0.6, height=2.5, radius=0.2
                
                // Position horizontal bar at top
                const horizontalPoints = horizontalBar.getPoints();
                horizontalPoints.forEach(point => {
                    point.y += 0.75; // Move up to top position
                });
                
                // Position vertical bar in center  
                const verticalPoints = verticalBar.getPoints();
                verticalPoints.forEach(point => {
                    point.y -= 0.25; // Move down slightly to center
                });
                
                // Create combined T shape
                // Start with horizontal bar
                const allPoints = horizontalPoints.concat(verticalPoints);
                
                // Use boolean operations to combine the shapes properly
                // For simplicity, we'll create the T using path operations
                const radius = 0.2;
                
                // Horizontal bar (top)
                tShape.moveTo(-1.5 + radius, 1);
                tShape.lineTo(1.5 - radius, 1);
                tShape.quadraticCurveTo(1.5, 1, 1.5, 1 - radius);
                tShape.lineTo(1.5, 0.5 + radius);
                tShape.quadraticCurveTo(1.5, 0.5, 1.5 - radius, 0.5);
                tShape.lineTo(0.3 + radius, 0.5);
                tShape.quadraticCurveTo(0.3, 0.5, 0.3, 0.5 - radius);
                
                // Vertical bar (right side)
                tShape.lineTo(0.3, -1.5 + radius);
                tShape.quadraticCurveTo(0.3, -1.5, 0.3 - radius, -1.5);
                tShape.lineTo(-0.3 + radius, -1.5);
                tShape.quadraticCurveTo(-0.3, -1.5, -0.3, -1.5 + radius);
                
                // Vertical bar (left side)
                tShape.lineTo(-0.3, 0.5 - radius);
                tShape.quadraticCurveTo(-0.3, 0.5, -0.3 - radius, 0.5);
                tShape.lineTo(-1.5 + radius, 0.5);
                tShape.quadraticCurveTo(-1.5, 0.5, -1.5, 0.5 + radius);
                tShape.lineTo(-1.5, 1 - radius);
                tShape.quadraticCurveTo(-1.5, 1, -1.5 + radius, 1);
                
                // Extrude the T shape to make it 3D
                const extrudeSettings = {
                    depth: 0.2,
                    bevelEnabled: true,
                    bevelSegments: 2,
                    steps: 2,
                    bevelSize: 0.1,
                    bevelThickness: 0.1
                };
                
                const tGeometry = new THREE.ExtrudeGeometry(tShape, extrudeSettings);
                
                // Use the same material as skateboard
                const tMaterial = new THREE.MeshPhongMaterial({
                    envMap: sphereCamera.renderTarget.texture
                });
                
                letterT = new THREE.Mesh(tGeometry, tMaterial);
                
                // Match the skateboard's initial rotation exactly and add 45-degree tilt
                letterT.rotation.copy(skate ? skate.rotation : new THREE.Euler(0, 0, 0));
                letterT.rotation.z += Math.PI / 4; // Add 45-degree tilt on Z-axis
                
                // Position the T below the skateboard with same X offset as skateboard
                if (window.innerWidth < 420) {
                    letterT.position.y = -5.38;
                    letterT.position.x = 1.6; // Same X as skateboard
                    letterT.scale.set(0.8, 0.8, 0.8);
                    tOriginalY = -5.38; // Store original Y position
                }
                else if (window.innerWidth < 770) {
                    letterT.position.y = -4.3;
                    letterT.position.x = 1; // Same X as skateboard
                    letterT.scale.set(0.9, 0.9, 0.9);
                    tOriginalY = -4.3; // Store original Y position
                }
                else if (window.innerWidth < 1050) {
                    letterT.position.y = -3.3;
                    letterT.position.x = 1; // Same X as skateboard
                    letterT.scale.set(0.7, 0.7, 0.7);
                    tOriginalY = -3.3; // Store original Y position
                }
                else if (window.innerWidth < 1500) {
                    letterT.position.y = -5.8;
                    letterT.position.x = 0; // Same X as skateboard
                    letterT.scale.set(1, 1, 1);
                    tOriginalY = -5.8; // Store original Y position
                }
                else if (window.innerWidth < 1550) {
                    letterT.position.y = -5.7;
                    letterT.position.x = 0; // Same X as skateboard
                    letterT.scale.set(1, 1, 1);
                    tOriginalY = -5.7; // Store original Y position
                }
                else {
                    letterT.position.y = -5.5;
                    letterT.position.x = 0; // Same X as skateboard
                    letterT.scale.set(1, 1, 1);
                    tOriginalY = -5.5; // Store original Y position
                }
                
                scene.add(letterT);
                console.log('Letter T added to scene');
            }

            // Original Rift lighting setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 1);
            scene.add(ambientLight);

            // Use exact original environment setup like the original Rift app
            let materialArray = [];
            let texture_ft = new THREE.TextureLoader().load('original_C.jpg');
            let texture_bk = new THREE.TextureLoader().load('original_C.jpg');
            let texture_up = new THREE.TextureLoader().load('original_C.jpg');
            let texture_dn = new THREE.TextureLoader().load('original_C.jpg');
            let texture_rt = new THREE.TextureLoader().load('original_C.jpg');
            let texture_lf = new THREE.TextureLoader().load('original_C.jpg');
            
            materialArray.push(new THREE.MeshBasicMaterial({ map: texture_ft }));
            materialArray.push(new THREE.MeshBasicMaterial({ map: texture_bk }));
            materialArray.push(new THREE.MeshBasicMaterial({ map: texture_up }));
            materialArray.push(new THREE.MeshBasicMaterial({ map: texture_dn }));
            materialArray.push(new THREE.MeshBasicMaterial({ map: texture_rt }));
            materialArray.push(new THREE.MeshBasicMaterial({ map: texture_lf }));
                 
            for (let i = 0; i < 6; i++)
                materialArray[i].side = THREE.BackSide;
                     
            let skyboxGeo = new THREE.SphereGeometry(9000000000000, 62, 62);
            let skybox = new THREE.Mesh(skyboxGeo, materialArray);
            scene.add(skybox);

            const sizes = {
                width: window.innerWidth,
                height: window.innerHeight
            }

            window.addEventListener('resize', () => {
                sizes.width = window.innerWidth;
                sizes.height = window.innerHeight;
                camera.aspect = sizes.width / sizes.height;
                camera.updateProjectionMatrix();
                renderer.setSize(sizes.width, sizes.height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            });
        }

        function moveCamera() {
            const t = new_body.scrollTop;

            // Exact camera movement logic from original
            if (window.innerWidth < 450) {
                camera.position.y = t * -0.006;
            }
            else if (window.innerWidth < 770) {
                camera.position.y = t * -0.004;
            }
            else if (window.innerWidth < 1050) {
                camera.position.y = t * -0.003;  
            }
            else if (window.innerWidth < 1500) {
                camera.position.y = t * -0.005;
            }
            else if (window.innerWidth < 1550) {
                camera.position.y = t * -0.005;
            }
            else {
                camera.position.y = t * -0.004;
            }
        }
        
        function render() {
            renderer.render(scene, camera);
            sphereCamera.update(renderer, scene);

            new_body.onscroll = moveCamera;

            requestAnimationFrame(render);

            // Exact rotation from original
            if (skate) {
                skate.rotation.x += -0.02;
            }
            
            // Multi-phase animation for the letter T
            if (letterT && animationPhase !== 'settled') {
                phaseTimer++;
                
                // Always rotate the T on an angle while animating (forward/backward)
                letterT.rotation.x += 0.08; // Rotate around X-axis for forward/backward motion
                
                if (animationPhase === 'hitBackground') {
                    // Phase 1: Move T to background
                    const progress = phaseTimer / hitBackgroundDuration;
                    if (progress < 1) {
                        letterT.position.z = -3 * progress; // Move to background (-3 units)
                    } else {
                        letterT.position.z = -3;
                        animationPhase = 'pause';
                        phaseTimer = 0;
                    }
                } else if (animationPhase === 'pause') {
                    // Phase 2: Pause at background
                    letterT.position.z = -3; // Stay at background
                    if (phaseTimer >= pauseDuration) {
                        animationPhase = 'bounce';
                        phaseTimer = 0;
                        bounceTime = 0;
                    }
                } else if (animationPhase === 'bounce') {
                    // Phase 3: Bounce up and down with decreasing intensity
                    if (bounceTime < maxBounceTime) {
                        bounceTime += 0.15; // Increment time for animation
                        const bounceHeight = 1.5; // How high to bounce up/down
                        
                        // Calculate damping factor to gradually reduce bounce amplitude
                        const dampingFactor = Math.max(0, 1 - (bounceTime / maxBounceTime));
                        
                        // Apply vertical bounce with exponential decay
                        letterT.position.y = tOriginalY + Math.sin(bounceTime) * bounceHeight * dampingFactor;
                        // Gradually move back to original Z position
                        const zProgress = bounceTime / maxBounceTime;
                        letterT.position.z = -3 + (3 * zProgress); // Move from -3 back to 0
                    } else {
                        // T has settled - stop at original position
                        letterT.position.y = tOriginalY;
                        letterT.position.z = 0;
                        animationPhase = 'settled';
                    }
                }
            }
        }

        function clearLoader() {
            loader.style.display = 'none';
        }

        // Start the app
        init();
    </script>
</body>
</html>
